<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <title>gblesson5.1</title>
</head>
<body>
<div id='id-test'>
    <h1 style='font-size: 80px'>Тестовая страница</h1>
    <div class='test-class'>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque ut lorem magna. Etiam aliquet purus mauris, et dapibus ante aliquam.</p> 
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque ut lorem magna. Etiam aliquet purus mauris, et dapibus ante aliquam.</p>
    </div>
    <div class='test-class'>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque ut lorem magna. Etiam aliquet purus mauris, et dapibus ante aliquam.</p> 
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque ut lorem magna. Etiam aliquet purus mauris, et dapibus ante aliquam.</p>
    </div>
</div>
<input type='text' value='Трамвайчик тронется'>
<a href='#' onclick='sayHello()'>link</a>
<script>
 
//console.log(document);
//console.dir(document);
//console.log(window.document);
//console.dir(window.document);

//=====================   Поиск   ==========================
//================   для простых вещей   ===================
//console.log(document.getElementById('id-test'));

//console.log(document.getElementsByClassName('test-class'))//это не массив, это html-коллекция 

//const elems = document.getElementsByClassName('test-class');//разбираем и копируем коллекцию в массив
//const elemsArr = [...elems];
//console.log(elemsArr[1].parentElement);
//console.log(elemsArr);
    
//console.log(document.getElementsByTagName('P'));//принято исп заглавные буквы при работе с тегами
    
//====================   query - запросы   ==================
//console.log(document.querySelector('.test-class:last-child'));//как в css, начинается с точки
//console.log(document.querySelector('.test-class:last-child')[0]);//идентично

//console.log(document.querySelectorAll('.test-class'));//есть NodeList, HTML-Collection, parrentElement и parrentMode
//========================================================

//====================   Перебор   =======================
//const pTags = document.querySelectorAll('p');
//for (let i = 0; i < pTags.length; i++) {
  //console.log(pTags[i]);
//}
    
//const pTags = [...document.querySelectorAll('p')];// то же самое, запись короче, через =>
//pTags.forEach((elem) => {
  //console.log(elem);
//});

//===================   Изменение   ===================//const h1Tag = document.querySelector('H1');
//console.log(h1Tag.textContent);
//console.log(h1Tag.innerText);//одинаково, различия будут если внутри будет контент, содержащий вложенные теги, будут различаться по поведению
//console.log(h1Tag.innerHTML);//если в <h1>Тестовая страница <b>Мефистофель</b></h1> т е можно добавлять теги

//const h1Tag = document.querySelector('H1');
//h1Tag.textContent = h1Tag.textContent + ', бля ! ';
//h1Tag.innerText = h1Tag.innerText + ', бля ! ';
//h1Tag.innerHTML = h1Tag.innerHTML + ', бля ! ';
//h1Tag.innerHTML = h1Tag.innerHTML + '<i>, бля !</i>';//оч
//ресурсозатратный, перелопачивает всю разметку, есть
//попроще варианты
//===========================================================
//т е на JS можно переписать весь наш HTML ? 
//да, на самом деле так оно и будет, мы будем делать базовую
//разметку, верстку, будем верстать какие то элементы, 
//блоки страниц, т е будет просто шаблон, а потом этот
//шаблон будем разбирать на куски и выносить все в JS,
//все это будет динамически генерироваться из JS'a
//приложение будет выглядеть вот так:

/*
<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <title>gblesson5.1</title>
</head>
<body>
<div id='app'></div>  //вот так будет выглядеть приложение
</body>
</html>
*/
//все остальное за вас делает JS
//в <div id='app'></div> вставиться все что нужно, вся  
//разметка - которая будет генерироваться в зависимости что 
//вообще за страницы, где вы находитесь, что вы делаете,
//какие кнопочки нажимаете - все это будет вариться в этом
//одном контейнере

//осваиваем динамическую работу с нашей разметкой

//===================  Стили  ======================= 
//<h1 style='font-size: 80px'>Тестовая страница</h1>//вот сюда вставляем значение

//console.log(h1Tag.style.fontSIze);//поиск по параметрам стиля,
//ключевое слово здесь: 'style'
//h1Tag.style.color='#f00';
//===========================
//через style я вообще не работаю, я использую другие
//методы, которые позволяют нам получить уже вычисленные
//текущие свойства css и с ними уже там, есть getComputedStyle
//который позволяет нам получить соответствующее значение
//чего либо, в числовом представлении, и с ним уже
//работать

//Напрямую стили менять не очень хорошо, это оч плохо
//лучше манипулировать классами - т е создавать какой
//то css класс и их уже добавлять/удалять, в зависимости
//от того как должен выглядеть ваш элемент текущий.

//const h1Tag = document.querySelector('H1');
//h1Tag.style.color='#f00';
//console.log(getComputedStyle(h1Tag));

//console.log(getComputedStyle(h1Tag).color);
//console.log(getComputedStyle(h1Tag).fontSize);

//======================  Создание  ======================

//const myDiv = document.createElement('DIV');
//myDiv.textContent = 'Peace, brothers!';

//document.querySelector('BODY').appendChild(myDiv);

//document.body.appendChild(myDiv);  //если надо быстро
//добраться до какого то элемента, но все же лучше прибегать
//к get-элементам, querySelector и другим более логичным
//в текущей ситуации вещам

//-Получается что можно иметь одну страничку html и на нашей
//что угодно создавать через js - это быстрее будет работать,
//чем загружать отдельные новые html-страницы ?

//-Да, в этом и есть вся красота и смысл SPA - 
//Single Page Application (Вики) - когда у нас есть одна
//html-страница, и в ней все варится, в зависимости от того
//что делает пользователь. Это достигается благодаря какому
//глобальному хранилищу данных, где хранится все наше
//приложение и роутинга.

//То есть есть роутер, который следит за тем куда вы тыкаетесь,
//по каким страницам переходите и в зависимости от того, какая
//страница нужна - он загружает контент нужной страницы, и все
//это оч классно работает, еще вкупе с реактивностью.

//Мы разговаривали о том, что innerHTML плохо, appendChild'ом
//тоже сыт не будешь, представьте если вам надо пилить какую то
//серьезную структуру, дикую разметку с кучей вложенных элементов,
//всякие там параграфы, гифки, прочие штуки - вы задолбаетесь
//писать -createElement, -appendChild, -createElement, 
//-appendChild, у вас просто будет дичайшая портянка кода, которую
//вы на следующий день забудете и не поймете что вы написали.

//сохранять какую то визуальную вложенность тоже не получится, 
//потому что это реально дичь будет, поэтому логичным тем, что
//захочется использовать следующим - это всю разметку записать
//как строку, например элементов пятьдесят, например вот такой кусок

/*
<div id='id-test'>
    <h1 style='font-size: 80px'>Тестовая страница</h1>
    <div class='test-class'>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> 
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>
    </div>
    <div class='test-class'>
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> 
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>
    </div>
</div>
*/
//можно, конечно, использовать HTML но это будет медленно, 
//неповоротливо, и вообще зачем так делать.

//================   insertAdjacentHTML   =================

//Есть другой способ, также можно сделать строку, также с ней
//после работать, как со строкой, с этой разметкой, но
//использовать другой метод для добавления этой разметки
//и называется он insertAdjacentHTML.

//document.body.insertAdjacentHtml() - вот сюда мы можем 
//скормить нашу разметку, и она корректно и правильно воткнется.
//у него есть insertPosition - 
//document.body.insertAdjacentHtml('beforebegin') - который
//будет ставится до элемента <body>.

//есть document.body.insertAdjacentHtml('afterbegin') - 
//который встанет в начало <body>

//есть document.body.insertAdjacentHtml('beforeend') - 
//то есть перед закрывающим </body>

//есть document.body.insertAdjacentHtml('afterend') - 
//который ставится за закрывающим </body>

//Все это дело нереально удобно работает
//вторым элементом можно скормить элемент, строку
//document.body.insertAdjacentHtml('afterend', elem)
//все это корректно распарсится, и вставится

//Как добавить кусок в HTML'e в тот же body ?
//body.innerHTML = body.innerHTML + '<i>, бля !</i>';
//А если у вас в body есть какая то разметка, в ней
//есть какие то элементы, на которые навешаны какие
//то события. Из-за таких действий у вас просто выгребается
//содержимое, снова копируется строчка, к этой строчке еще
//еще добавляется строчка(не полноценная разметка, скорее 
//строковое представление нашей разметки, потом все это дело
//парсится, из строки создаются новые элементы, абсолютно
//и записываются в innerHTML. У вас полностью поменялась
//разметка, от и до, от открывающего тега до закрывающего.

//document.body.insertAdjacentHtml('afterend') корректно
//формирует из того, что было и того что мы дали, элементы
//и добавляет их как бы это делал appendChild, он не трогает
//то что было до него, он никак не ломает текущую структуру.

//Это оч удобно, это оч производительно, браузер не делает
//тонну операций по парсингу, копированию, это работает в
//разы быстрее нежели innerHTML

//БОЛЕЕ ДЕТАЛЬНО НУЖНО СМОТРЕТЬ В ДОКУМЕНТАЦИИ.

//============================
//как работает beforebegin/beforeend с тегами, которые не
//имеют закрывающих тегов ?

//например вставляем input после закрывающего тега
////</div>
////<input type='text' value='Трамвачик тронется'>
////<script>

//const h1Tag = document.querySelector('H1');
//const myDiv = document.createElement('DIV');
//const input = document.querySelector('INPUT');
//input.insertAdjacentHTML('beforebegin', '<b>Мандося бельды</b>');
//input.insertAdjacentHTML('afterend', '<b>ЧебураторЧебоксары</b>');

//Все это применяется для динамического добавления разметки
//каких либо элементов, других вещей, которые формируются где то
//както, в зависимости от действий пользователя и нам что то надо
//куда то добавлять, при этом не сломав ничего что было.

//Допустим он формирует список, добавляет какие то элементы в 
//корзину, нажал "ДОБавить", и у нас полетело в корзинку.

//если обобщить все вкратце, то все это используется для динамической
//генерации разметки в зависимости от поведения пользователя

//=====================================
//допустим у нас есть h1Tag который мы хотим куда то переместить
//что бы нам воспользоваться parrentElement'oм нам нужно ему указывать
//чего и перед чем ставить, т е целевой элемент относительно которого
//он будет ориентироваться, где refElem у нас это вот этот блок

////<div class='test-class'>
      ////<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> 
      ////<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>
////</div>

//const h1Tag = document.querySelector('H1');
//const parrentElement = document.querySelector('#id-test');
//const refElem = document.querySelector('.test-class:last-child');
//parrentElement.insertBefore(h1Tag, refElem);

//что получилось ? - Мы просто не скопировали элемент, а вырезали его
//а мы хотим получить копию. Получаем

//const h1Tag = document.querySelector('H1').cloneNode(true);
//const parrentElement = document.querySelector('#id-test');
//const refElem = document.querySelector('.test-class:last-child');
//parrentElement.insertBefore(h1Tag, refElem);

//вставляем в указанное нами место. Таким образом мы можем наши
//узлы также и копировать. Если не используем cloneNode  - мы просто
//перемещаем. Это удобно делать если используется какой нить 
//Drag-n-Drop - интерфейс. Выделили элемент и кудато утащили, отпустили
//мышку - он переместился. Таким способом происходит перемещение.

//Современный поисковик не на 100%, но умеет работать с такими 
//приложениями как React и Vue, он определяет что на вашем приложении
//есть какая то реактивная штучка, React или Vue, и умеет отрендеривать
//страницы при индексировании и получать полную разметку, и сохранять
//это в индекс, ну както своими способами.

//Это и большущий минус SPA приложений. Плюсы: это удобство разработки,
//удобство работы с ними, это очень удобно - это реактивно, быстро, 
//стильно, модно, молодежно и производительно. Но это как раз и 
//накладывает определенные ограничения: это индексация поисковиками - 
//в лучшем случае прочитает название странички вашего сайта, в худшем -
//ничего не возьмет.

//Поэтому большинство сейчас смотрит на SSR - server site rendering,
//чтобы конкретно когда поисковик приходит по какому то URL'у,
//пытается чтото найти, както проиндексировать ваш сайт, при обращении
//к нем он изначально получает вполне валидную разметку, полноценную,
//с типичным представлением страниц.

//То есть по факту ему не интересно что за скрипты у вас подключены,
//он смотрит на разметку, на метатеги, на хедеры, футеры, naf, т е
//все что связано с семантикой. Все это запоминает, если видит naf
//(React, умеет сжимать картинки, css, js) то смотрит куда обращается
//ваша страничка, соотв, шлет вопрос опять на сервер, сервер опять
//обрабатывает, понимая, что кто то хочет от него что то получить,
//какието данные по текущему URL'у, там же все аутится, и опять же
//подается корректное представление

//Если брать на примере VueJS'a то это будет naf, отлично работает 
//на стороне сервера и уже выплевывает поисковикам вполне себе
//вкусные странички для обработки.

//======================   Удаление   =========================
//const h1Tag = document.querySelector('H1');
//h1Tag.remove();

//==========   Семейные отношения элементов   ================
//const h1Tag = document.querySelector('H1');
//console.log(h1Tag.parentElement);
//console.log(h1Tag.parentElement.children);
//console.log(h1Tag.parentElement.children[2]);
//console.log(h1Tag.parentElement.children[1],[2]);
//console.log(h1Tag.parentElement.children[1].querySelector('p:last-child'));
//querySelector есть у любого элемента с DOM, где р - это параграф

//========================   События   =======================
//События могут быть мыши, клавиатуры, скроллинга, загуглить
//events, посмотреть какие события могут быть

//В подавляющем большинстве - события мыши, и клавиатуры
//События возникают, обрабатываются, и то что происходит во
//время какоего то события реализуется при помощи ФУНКЦИЙ - 
//ОБРАБОТЧИКОВ СОБЫТИЙ, их надо описывать и они что то будут
//делать

//function sayHello() {  //дикий html
  //alert('обезьяна');
//}
////вот для этого ссылки <a href='#' onclick='sayHello()'>link</a>


//const h1Tag = document.querySelector('H1');
//h1Tag.onclick = function () {  //это клик по заголовку h1Tag
  //alert('ОбезьянаОбезьяна');   //этот первый работать не будет
//};
//h1Tag.onclick = function () {  //это клик по заголовку h1Tag
  //alert('Дима обезьяна');
//};
//h1Tag.onclick = null;  //выключили клик
//это все прошлый век, так делать не надо


//==== Прослушиватель (обработчик) событий =====

/*
//h1Tag.addEventListener();
//передаем два аргумента: 1.какое событие будем слушать
//2.функция, которая будет это обрабатывать

function sayHello() {  
  alert('вова обезьяна');
};  

const h1Tag = document.querySelector('H1');

h1Tag.addEventListener('click', function () {
  console.log('обезьяна');
});//клик по заголовку

h1Tag.addEventListener('click', sayHello);   
  //функция обьявленная, скобки не нужны !!! клик по линку

//на клик можно повесить 50 обработчиков, для выполнения
//различных задач, ровно как и на любое другое событие

//обрабатывая какое то событие нам в большинстве случаев
//внутри этого обработчика получить доступ к контексту выше,
//то что мы делали ранее: какую то переменную посчитать, какие
//то значения получить, и если это делать через нонейм функцию
//function (), не стрелочная функция, то она изолирует область
//видимости и ничего не получится. 

//В этих случаях нас спасают стрелочные функции

h1Tag.addEventListener('click', () => {
  console.log('дима обезьяна');
});  

//======= Удаление ========
//h1Tag.removeEventListener

//h1Tag.removeEventListener('click, function () {
  //console.log('обезьяна')
//});
 //так не удалит, не поймет какую функцию удалять
//у них идентичный функционал, но это две разные ячейки памяти
//Чтобы удалить обработчик, нужно указать ту функцию, которая 
//изначально делегирована

//Вот так удалит
h1Tag.removeEventListener('click', sayHello);

//Соответственно, чтобы нам корректно удалять какие то события
//не забывайте функции - обработчики както описывать лучше
//и их уже передавать сюда
*/
//==================
/*
//можно узнать, на что именно был клик
function sayHello(event) {
  alert('Hello');
  console.log(event);
  //console.log(event.target);//клик по обьекту
  console.log(event.currentTarget);//есть различия между
  //target и currentTarget, то есть клик был по <p> или по <div>
}
const h1Tag = document.querySelector('H1');
h1Tag.addEventListener('click', sayHello);
//прилетает лог клика мыши со всеми параметрами: зажата ли
//клавиша alt,путь события, время клика, местоположение курсора, 
//тип события
*/

//Как передать аргумент в функцию ?
//вот сюда h1Tag.addEventListener('click', sayHello) хотим передать значение
//h1Tag.addEventListener('click', sayHello(name))
//Изначально нужн пытаться построить логику так, чтобы такой необходимости
//не возникало. Если нужно чтото с элементов дергать, то нужно через 
//target посмотреть, и тогда какието приблуды вшить на момент рендера,
//чтобы не делать какието дополнительные вещи

/*
function sayHello(name) {
  alert('Hello');
  console.log(name);
};
const h1Tag = document.querySelector('H1');
h1Tag.addEventListener('click', () => sayHello('ДимаОбезьяна'));
*/

//еще так
/*
function sayHello(name) {
  alert('Hello');
  console.log(name);
  console.log(this);
};
const h1Tag = document.querySelector('H1');
h1Tag.addEventListener('click', () => sayHello('ДимаОбезьяна'));
*/

/*
//или так, в данном случае this - это элемент, который мы прожали
function sayHello(name = '') {
  alert('Hello');
  console.log(name);
  console.log(this);
};
const h1Tag = document.querySelector('H1');
h1Tag.addEventListener('click', sayHello);
*/

//на самом деле тут такая тонкая грань, в которой надо уметь
//балансировать, что нам нужно - либо аргумент, либо event,
//либо все вместе, и тут приходится шаманить с этими параметрами, 

//опять же не каждый браузер это определит, напр в FF это не 
//сработает, он event'a не увидит, event is not defainde,

//можно писать сокращенно е от event, понимая что это обьект event

//===============   События документа   =================
/*

//эти штуки используются для внедрения какихто метрик, статистики,
//совсем небольшого подключаемого функционала, какихто библиотечек,
//которые анимашки допиливают вам независимо от вашего функционала, 
//и так далее, например если пользователь чтото прожал, то чтото
//подключилось конкретное, при этом не лезть в основной код, то
//есть как отдельное временное событие у вас есть на сайте, то
//вы берете, вставляете DOMContentLoaded, выбираете нужные 
//элементы и подключаете вашу библиотеку, которая будет 
//обрабатывать нужный элемент
window.addEventListener('load', function () {
  alert('1111');
});  //срабатывает когда страничка загрузилась, включая зазметку,
//стили, менюшки, подгрузятся картинки, то есть полностью со всеми
//ресурсами, когда сработает событие 'load'

document.addEventListener('DOMContentLoaded', function () {
  alert('2222');
});  //из названия понятно, когда загрузится DOM, DOM-модель
//построена, разметка готова, не дожидаемся картинок, загрузки
//стилей, ничего не ждем, как только разметка полностью создалась, 
//у нас создался DOM-обьект, в данный момент мы начинаем работу
//с нашим документом, а страница еще может продолжает загружаться

//вот это надо писать когда вы неуверенны в том, где вообще этот
//скрипт будет подключаться, то есть оборачивать в DOMContentLoaded,
//но оборачивать нехорошо, так что в идеале все скрипты нужно
//писать без этой штуки. И функционально что отвечает за приложение
//и подключать их уже либо через async либо defer
//=====================
//сейчас практически нет такого безобразия
window.addEventListener('load', function () {
  alert('3333');
}); //когда вы нажимали "закрыть страницу", у вас выскакивает
//это событие, тут можно было практически отменить действие
//закрытия страницы и достать пользователя различными вопросами
//из серии "ты хочешь покинуть эту страницу, а нас еще есть то-то
//и то-то, и ты вообще давай еще туда сходи", то есть более
//навязчиво себя вести, раньше это очень практиковалось
*/

//=========== Общие вопросы =============

//Получается, что стрелочные функции записываются в переменные ?
//Да

//
//А страницы на других сайтах так можно прослушивать, парсить
//и редактировать ?

//Парсить другие сайты можно, просто вы делаете XHR-запрос, 
//считываете все содержимое страницы, которую вам вернет
//и парсите как то, но чтобы прослушивалки на чужой сайт - это
//нет. Так не получится.



//2:27 лекции - игра "змейка"






</script>
</body>
</html>










